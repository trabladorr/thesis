#ifndef _MULT_BITSLICE_XORMULT_INLINE
#define _MULT_BITSLICE_XORMULT_INLINE

//calculates multiplication by two in the Anubis Field
//input/output: 8x128 bit bitsliced vectors
static inline void x2_8x128(__m128i *input){
	__m128i tmp0 = input[0];
	input[0] = input[1];
	input[1] = input[2];
	input[2] = input[3];
	input[3] = _mm_xor_si128 (input[4],tmp0);
	input[4] = _mm_xor_si128 (input[5],tmp0);
	input[5] = _mm_xor_si128 (input[6],tmp0);
	input[6] = input[7];
	input[7] = tmp0;
}

//calculates multiplication by 6/4 in the Anubis Field
//input/output: 8x128 bit bitsliced vectors
static inline void x6div4_8x128(__m128i *input){
	__m128i tmp7 = input[7];	
	input[7] = _mm_xor_si128 (input[6],input[7]);
	input[6] = _mm_xor_si128 (input[5],input[7]);
	__m128i tmp4xor7 = _mm_xor_si128 (input[4],tmp7);
	input[5] = _mm_xor_si128 (input[5],tmp4xor7);
	input[4] = _mm_xor_si128 (input[3],tmp4xor7);
	input[3] = _mm_xor_si128 (input[2],input[3]);
	input[2] = _mm_xor_si128 (input[1],input[2]);
	input[1] = _mm_xor_si128 (input[0],input[1]);
	input[0] = _mm_xor_si128 (input[0],tmp7);
}

//set all 8 128 output registers to input
static inline void set_8x128(__m128i *output,__m128i *input){
	output[0] = input[0];
	output[1] = input[1];
	output[2] = input[2];
	output[3] = input[3];
	output[4] = input[4];
	output[5] = input[5];
	output[6] = input[6];
	output[7] = input[7];
}

//output = output XOR input
//8x128 bit bitsliced vectors
static inline void xor_8x128(__m128i *output,__m128i *input){
	output[0] = _mm_xor_si128(output[0],input[0]);
	output[1] = _mm_xor_si128(output[1],input[1]);
	output[2] = _mm_xor_si128(output[2],input[2]);
	output[3] = _mm_xor_si128(output[3],input[3]);
	output[4] = _mm_xor_si128(output[4],input[4]);
	output[5] = _mm_xor_si128(output[5],input[5]);
	output[6] = _mm_xor_si128(output[6],input[6]);
	output[7] = _mm_xor_si128(output[7],input[7]);
}

//calculates multiplication by four in the Anubis Field
//input/output: 32x128 bit bitsliced vectors
//automatically generated by sage script, all common intermediaries defined as tmpX
static inline void anubis_mult_128_xor_opt_tmp(__m128i input[], __m128i output[]){
	__m128i tmp0 = input[17] ^ input[25];
	__m128i tmp1 = input[1] ^ input[9];
	__m128i tmp2 = input[16] ^ input[28];
	__m128i tmp3 = input[8] ^ input[24];
	__m128i tmp4 = input[0] ^ tmp0;
	__m128i tmp5 = input[0] ^ input[8];
	__m128i tmp6 = input[20] ^ input[24];
	__m128i tmp7 = input[0] ^ tmp1;
	__m128i tmp8 = input[16] ^ input[22];
	__m128i tmp9 = input[10] ^ input[17];
	__m128i tmp10 = input[13] ^ tmp7;
	__m128i tmp11 = input[3] ^ input[26];
	__m128i tmp12 = input[5] ^ tmp1;
	__m128i tmp13 = input[23] ^ tmp3;
	__m128i tmp14 = input[11] ^ input[27];
	__m128i tmp15 = input[8] ^ input[21];
	__m128i tmp16 = input[29] ^ tmp8;
	__m128i tmp17 = input[5] ^ input[24];
	__m128i tmp18 = input[18] ^ input[25];
	__m128i tmp19 = tmp2 ^ tmp15;
	__m128i tmp20 = input[15] ^ input[16];
	__m128i tmp21 = input[1] ^ input[26];
	__m128i tmp22 = input[29] ^ tmp6;
	__m128i tmp23 = input[4] ^ input[12];
	__m128i tmp24 = input[6] ^ input[14];
	__m128i tmp25 = input[7] ^ input[15];
	__m128i tmp26 = input[10] ^ input[19];
	__m128i tmp27 = input[21] ^ input[30];
	__m128i tmp28 = tmp2 ^ tmp6;
	__m128i tmp29 = input[8] ^ input[13];
	__m128i tmp30 = input[4] ^ tmp29;
	__m128i tmp31 = tmp5 ^ tmp23;
	__m128i tmp32 = input[6] ^ input[31];
	__m128i tmp33 = input[2] ^ input[9];
	__m128i tmp34 = input[7] ^ input[23];
	__m128i tmp35 = input[12] ^ tmp17;
	__m128i tmp36 = input[30] ^ tmp0;
	
	output[0] = input[0] ^ input[9] ^ input[26] ^ tmp18;
	output[1] = input[27] ^ tmp21 ^ tmp26;
	output[2] = input[2] ^ tmp14 ^ tmp28;
	output[3] = input[3] ^ input[12] ^ input[29] ^ tmp0 ^ tmp19;
	output[4] = tmp16 ^ tmp30 ^ tmp36;
	output[5] = input[5] ^ input[14] ^ input[31] ^ tmp13 ^ tmp36;
	output[6] = input[24] ^ tmp20 ^ tmp32;
	output[7] = input[7] ^ tmp0 ^ tmp3;
	output[8] = input[8] ^ input[17] ^ input[18] ^ tmp21;
	output[9] = input[18] ^ input[19] ^ input[27] ^ tmp33;
	output[10] = input[3] ^ tmp26 ^ tmp28;
	output[11] = input[4] ^ input[11] ^ input[21] ^ tmp4 ^ tmp22;
	output[12] = input[22] ^ tmp4 ^ tmp27 ^ tmp35;
	output[13] = input[13] ^ input[23] ^ tmp4 ^ tmp8 ^ tmp32;
	output[14] = input[14] ^ input[16] ^ input[24] ^ tmp34;
	output[15] = tmp4 ^ tmp20;
	output[16] = input[10] ^ input[16] ^ input[25] ^ tmp33;
	output[17] = input[11] ^ tmp9 ^ tmp11;
	output[18] = input[18] ^ tmp14 ^ tmp31;
	output[19] = input[19] ^ input[28] ^ tmp10 ^ tmp35;
	output[20] = tmp10 ^ tmp22 ^ tmp24;
	output[21] = input[14] ^ tmp1 ^ tmp3 ^ tmp25 ^ tmp27;
	output[22] = input[15] ^ input[22] ^ input[31] ^ tmp5;
	output[23] = tmp1 ^ tmp13;
	output[24] = input[1] ^ input[2] ^ input[24] ^ tmp9;
	output[25] = input[2] ^ input[3] ^ input[11] ^ tmp18;
	output[26] = input[19] ^ tmp11 ^ tmp31;
	output[27] = input[16] ^ input[20] ^ input[27] ^ tmp12 ^ tmp30;
	output[28] = tmp12 ^ tmp19 ^ tmp24;
	output[29] = input[6] ^ tmp7 ^ tmp16 ^ tmp25;
	output[30] = input[30] ^ tmp5 ^ tmp34;
	output[31] = input[16] ^ input[31] ^ tmp7;
}

//calculates multiplication by four in the Anubis Field
//input/output: 32x128 bit bitsliced vectors
//automatically generated by sage script, xors match xor count
static inline void anubis_mult_128_xor_opt_compiler(__m128i input[], __m128i output[]){
	output[0] = input[0] ^ input[9] ^ input[18] ^ input[25] ^ input[26];
	output[1] = input[1] ^ input[10] ^ input[19] ^ input[26] ^ input[27];
	output[2] = input[2] ^ input[11] ^ input[16] ^ input[20] ^ input[24] ^ input[27] ^ input[28];
	output[3] = input[3] ^ input[8] ^ input[12] ^ input[16] ^ input[17] ^ input[21] ^ input[25] ^ input[28] ^ input[29];
	output[4] = input[4] ^ input[8] ^ input[13] ^ input[16] ^ input[17] ^ input[22] ^ input[25] ^ input[29] ^ input[30];
	output[5] = input[5] ^ input[8] ^ input[14] ^ input[17] ^ input[23] ^ input[24] ^ input[25] ^ input[30] ^ input[31];
	output[6] = input[6] ^ input[15] ^ input[16] ^ input[24] ^ input[31];
	output[7] = input[7] ^ input[8] ^ input[17] ^ input[24] ^ input[25];
	output[8] = input[1] ^ input[8] ^ input[17] ^ input[18] ^ input[26];
	output[9] = input[2] ^ input[9] ^ input[18] ^ input[19] ^ input[27];
	output[10] = input[3] ^ input[10] ^ input[16] ^ input[19] ^ input[20] ^ input[24] ^ input[28];
	output[11] = input[0] ^ input[4] ^ input[11] ^ input[17] ^ input[20] ^ input[21] ^ input[24] ^ input[25] ^ input[29];
	output[12] = input[0] ^ input[5] ^ input[12] ^ input[17] ^ input[21] ^ input[22] ^ input[24] ^ input[25] ^ input[30];
	output[13] = input[0] ^ input[6] ^ input[13] ^ input[16] ^ input[17] ^ input[22] ^ input[23] ^ input[25] ^ input[31];
	output[14] = input[7] ^ input[14] ^ input[16] ^ input[23] ^ input[24];
	output[15] = input[0] ^ input[15] ^ input[16] ^ input[17] ^ input[25];
	output[16] = input[2] ^ input[9] ^ input[10] ^ input[16] ^ input[25];
	output[17] = input[3] ^ input[10] ^ input[11] ^ input[17] ^ input[26];
	output[18] = input[0] ^ input[4] ^ input[8] ^ input[11] ^ input[12] ^ input[18] ^ input[27];
	output[19] = input[0] ^ input[1] ^ input[5] ^ input[9] ^ input[12] ^ input[13] ^ input[19] ^ input[24] ^ input[28];
	output[20] = input[0] ^ input[1] ^ input[6] ^ input[9] ^ input[13] ^ input[14] ^ input[20] ^ input[24] ^ input[29];
	output[21] = input[1] ^ input[7] ^ input[8] ^ input[9] ^ input[14] ^ input[15] ^ input[21] ^ input[24] ^ input[30];
	output[22] = input[0] ^ input[8] ^ input[15] ^ input[22] ^ input[31];
	output[23] = input[1] ^ input[8] ^ input[9] ^ input[23] ^ input[24];
	output[24] = input[1] ^ input[2] ^ input[10] ^ input[17] ^ input[24];
	output[25] = input[2] ^ input[3] ^ input[11] ^ input[18] ^ input[25];
	output[26] = input[0] ^ input[3] ^ input[4] ^ input[8] ^ input[12] ^ input[19] ^ input[26];
	output[27] = input[1] ^ input[4] ^ input[5] ^ input[8] ^ input[9] ^ input[13] ^ input[16] ^ input[20] ^ input[27];
	output[28] = input[1] ^ input[5] ^ input[6] ^ input[8] ^ input[9] ^ input[14] ^ input[16] ^ input[21] ^ input[28];
	output[29] = input[0] ^ input[1] ^ input[6] ^ input[7] ^ input[9] ^ input[15] ^ input[16] ^ input[22] ^ input[29];
	output[30] = input[0] ^ input[7] ^ input[8] ^ input[23] ^ input[30];
	output[31] = input[0] ^ input[1] ^ input[9] ^ input[16] ^ input[31];
}


//calculates multiplication by four in the Anubis Field
//input/output: 32x128 bit bitsliced vectors
static inline void anubis_mult_128_xor(__m128i input[], __m128i output[]){

	//add x1 vectors to output, as defined by the hadamard matrix
	set_8x128(output,input);
	set_8x128(output+8,input+8);
	set_8x128(output+16,input+16);
	set_8x128(output+24,input+24);

	//multiply input inplace x2
	x2_8x128(input);
	x2_8x128(input+8);
	x2_8x128(input+16);
	x2_8x128(input+24);

	//add x2 vectors to output, as defined by the hadamard matrix
	xor_8x128(output,input+8);
	xor_8x128(output+8,input);
	xor_8x128(output+16,input+24);
	xor_8x128(output+24,input+16);

	//multiply input inplace x2, to a cumulative x4
	x2_8x128(input);
	x2_8x128(input+8);
	x2_8x128(input+16);
	x2_8x128(input+24);

	//add x4 vectors to output, as defined by the hadamard matrix
	xor_8x128(output,input+16);
	xor_8x128(output+8,input+24);
	xor_8x128(output+16,input);
	xor_8x128(output+24,input+8);

	//multiply input inplace x4/6, to a cumulative x6
	x6div4_8x128(input);
	x6div4_8x128(input+8);
	x6div4_8x128(input+16);
	x6div4_8x128(input+24);

	//add x6 vectors to output, as defined by the hadamard matrix
	xor_8x128(output,input+24);
	xor_8x128(output+8,input+16);
	xor_8x128(output+16,input+8);
	xor_8x128(output+24,input);

	

}

// https://mischasan.wordpress.com/2011/07/24/what-is-sse-good-for-transposing-a-bit-matrix/
// transpose a bit[8][16] matrix (16 8-bit numbers in an __m128i) 
// into a bit[16][8] matrix (8 16-bit numbers, first all the 16 0th bits, then the 1st bits, etc)
static inline __m128i sse_trans_slice(__m128i x){

    union { unsigned short s[8]; __m128i m; } u;
    int i;
    for (i = 0; i < 8; ++i) {
        u.s[7-i]= _mm_movemask_epi8(x);
        x = _mm_slli_epi64(x,1);
    }
    return  u.m;
}

static inline void sse_trans_slice_x4(__m128i input[]){
	input[0] = sse_trans_slice(input[0]);
	input[1] = sse_trans_slice(input[1]);
	input[2] = sse_trans_slice(input[2]);
	input[3] = sse_trans_slice(input[3]);
}

static inline void sse_trans_slice_4x8(__m128i input[]){
	sse_trans_slice_x4(input);
	sse_trans_slice_x4(input+4);
	sse_trans_slice_x4(input+8);
	sse_trans_slice_x4(input+12);
	sse_trans_slice_x4(input+16);
	sse_trans_slice_x4(input+20);
	sse_trans_slice_x4(input+24);
	sse_trans_slice_x4(input+28);
}

static inline __m128i sse_trans_slice_rev(__m128i x){
	const __m128i shuffle_mask = _mm_setr_epi8(0x0, 0x2, 0x4, 0x6, 0x8, 0xa, 0xc, 0xe, 0x1, 0x3, 0x5, 0x7, 0x9, 0xb, 0xd, 0xf);
    x = _mm_shuffle_epi8(x,shuffle_mask);
    return _mm_shuffle_epi8(sse_trans_slice(x),shuffle_mask);
}

static inline void sse_trans_slice_x4_rev(__m128i input[]){
	input[0] = sse_trans_slice_rev(input[0]);
	input[1] = sse_trans_slice_rev(input[1]);
	input[2] = sse_trans_slice_rev(input[2]);
	input[3] = sse_trans_slice_rev(input[3]);
}

static inline void sse_trans_slice_4x8_rev(__m128i input[]){
	sse_trans_slice_x4_rev(input);
	sse_trans_slice_x4_rev(input+4);
	sse_trans_slice_x4_rev(input+8);
	sse_trans_slice_x4_rev(input+12);
	sse_trans_slice_x4_rev(input+16);
	sse_trans_slice_x4_rev(input+20);
	sse_trans_slice_x4_rev(input+24);
	sse_trans_slice_x4_rev(input+28);
}

static inline void copy_32x128(__m128i to[],__m128i from[]){
	int i;
	for (i=0;i<32;i++)
	 	to[i]=from[i];
}

static inline void rearrange(__m128i input[],__m128i tmp[]){
	
	int i,j;

	copy_32x128(tmp,input);

	for (i=0;i<4;i++)
		for (j=0;j<8;j++)
			input[j+i*8]=tmp[i+j*4];
}

static inline void rearrange_rev(__m128i input[],__m128i tmp[]){
	
	int i,j;

	for (i=0;i<4;i++)
		for (j=0;j<8;j++)
			input[i+j*4]=tmp[j+i*8];
}

static inline void transpose_8x8_16bit(__m128i input[]){

	__m128i tmp0 = _mm_unpacklo_epi16(input[0], input[1]);
	__m128i tmp1 = _mm_unpacklo_epi16(input[2], input[3]);
	__m128i tmp2 = _mm_unpacklo_epi16(input[4], input[5]);
	__m128i tmp3 = _mm_unpacklo_epi16(input[6], input[7]);
	__m128i tmp4 = _mm_unpackhi_epi16(input[0], input[1]);
	__m128i tmp5 = _mm_unpackhi_epi16(input[2], input[3]);
	__m128i tmp6 = _mm_unpackhi_epi16(input[4], input[5]);
	__m128i tmp7 = _mm_unpackhi_epi16(input[6], input[7]);	

	input[0] = tmp0;
	input[1] = tmp1;
	input[2] = tmp2;
	input[3] = tmp3;
	input[4] = tmp4;
	input[5] = tmp5;
	input[6] = tmp6;
	input[7] = tmp7;


	// input[7] = tmp0;
	// input[6] = tmp1;
	// input[5] = tmp2;
	// input[4] = tmp3;
	// input[3] = tmp4;
	// input[2] = tmp5;
	// input[1] = tmp6;
	// input[0] = tmp7;

	transpose_4x4_32bit(input);
	transpose_4x4_32bit(input+4);
}

static inline void inverse_8x128(__m128i input[]){
	__m128i tmp0 = input[0];
	__m128i tmp1 = input[1];
	__m128i tmp2 = input[2];
	__m128i tmp3 = input[3];
	input[0] = input[7];
	input[1] = input[6];
	input[2] = input[5];
	input[3] = input[4];
	input[4] = tmp3;
	input[5] = tmp2;
	input[6] = tmp1;
	input[7] = tmp0;
}

static inline void into_bitslice(__m128i input[],__m128i tmp[]){

	into_byteslice_4x128(input);
	into_byteslice_4x128(input+4);
	into_byteslice_4x128(input+8);
	into_byteslice_4x128(input+12);
	into_byteslice_4x128(input+16);
	into_byteslice_4x128(input+20);
	into_byteslice_4x128(input+24);
	into_byteslice_4x128(input+28);
	
	//Rearrange innput vectors 
	rearrange(input,tmp);

	//Do sse_trans_slice() on every 128-bit vector of each of 8 groups (32 calls to sse_trans_slice())

	sse_trans_slice_4x8(input);

	//Each of the 8 byteslices is now bit-sliced: 8 groups, each with 4 128-bit vectors, each with 8 16-bit values
	//transpose the 32x8 16bit matrix
	transpose_8x8_16bit(input);
	transpose_8x8_16bit(input+8);
	transpose_8x8_16bit(input+16);
	transpose_8x8_16bit(input+24);

	//bitslicing done
	inverse_8x128(input);
	inverse_8x128(input+8);
	inverse_8x128(input+16);
	inverse_8x128(input+24);
}

static inline void from_bitslice(__m128i input[],__m128i tmp[]){
	//do the reverse of loading!
	inverse_8x128(tmp);
	inverse_8x128(tmp+8);
	inverse_8x128(tmp+16);
	inverse_8x128(tmp+24);


	transpose_8x8_16bit(tmp);
	transpose_8x8_16bit(tmp+8);
	transpose_8x8_16bit(tmp+16);
	transpose_8x8_16bit(tmp+24);

	sse_trans_slice_4x8_rev(tmp);


	rearrange_rev(input,tmp);


	from_byteslice_4x128(input);
	from_byteslice_4x128(input+4);
	from_byteslice_4x128(input+8);
	from_byteslice_4x128(input+12);
	from_byteslice_4x128(input+16);
	from_byteslice_4x128(input+20);
	from_byteslice_4x128(input+24);
	from_byteslice_4x128(input+28);
}

//calculates multiplication by four in the Anubis Field
//input/output: 128 32-bit vectors to multiply
static inline void anubis_mult_128_xor_mem(__m128i input[]){
	__m128i tmp[32];

	into_bitslice(input,tmp);

	anubis_mult_128_xor(input,tmp);
	// copy_32x128(tmp,input);

	from_bitslice(input,tmp);
}

#endif